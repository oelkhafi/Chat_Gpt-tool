import sys
import math
from collections import defaultdict, deque

# алгоритм эдмондса-карпа поиска пропускной способности сети
def ek_max_flow(input_lines):
    # словарь словарей ""r"" хранит ненулевые остатки пропускной способности
    # для каждого ребра из вершины ""a"" в вершину ""b"" в ячейке r[a][b]
    # хранится остаток пропускной способности ребра. при увеличении потока
    # через ребро остаток уменьшается. рёбра, в которых пропускная способность
    # упала до нуля, удаляются аллгоритмом.
    r = defaultdict(dict)
    # номер начальной вершины всегда 0
    next(input_lines)  # пропускаем строку с числом вершин (вычислим автоматически)
    t = 0
    for line in input_lines:
        # a - вершина начала ребра, b - конец ребра, с - пропускная способность
        a, b, c = map(int, line.split())
        if a != b and c > 0:  # добавляем только рёбра с ненулевой пропускной способностью
            r[a][b] = c
        t = max(t, a, b)  # номер конечной вершины - наибольший среди найденных

    f = 0  # накопленное значение потока в конечной вершине
    while 1:
        # поиском в щирину ищем кратчайший путь из начальной вершины в конечную
        q = deque([0])  # очередь просмотра вершин сети
        v = set([0])    # множество уже просмотренных вершин
        p = {}   # накопленный путь в виде словаря: p[конец_ребра] -> начало_ребра
        while q:
            a = q.popleft()
            if a == t:  # достигли конечной вершины?
                break
            for b in r[a]:  # пройдём в все рёбра, где осталась пропускная способность
                if b not in v:  # ещё не просматривали?
                    p[b] = a
                    v.add(b)
                    q.append(b)
        else:         # ""else"": цикл закончился без break'a, то есть конца мы не достигли
            return f  # значит, больше путей нет. возвращаем накопленную сумму потока

        # найдём минимум остатка пропускной способности среди рёбер вдоль найденного пути
        d = math.inf
        b = t     # проходим путь от конечной вершины
        while b:  # до начальной вершины с номером 0 (т.е. пока b>0)
            a = p[b]
            d = min(d, r[a][b])
            b = a

        # теперь модифицируем граф остатков
        b = t    # повторно проходим путь от конца в начало
        while b:
            a = p[b]
            r[a][b] -= d     # вычитаем найденный минимум из остатка пропускной способности
            if not r[a][b]:  # удаляем рёбра, в которых пропускная способность исчерпана
                del r[a][b]
            if b == t:  # значение потока вычисляем по конечной вершине
                f += d  # из остатка вычли, к потоку добавляем
            b = a

print(ek_max_flow(line for line in sys.stdin)) 