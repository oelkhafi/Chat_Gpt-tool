from math import log

# моя попытка написать оптимизированный перебор путей на Python
def kpaths(input_str):
    # input_str - входная строка
    start, end = input_str.split()
    
    # оцениваем длину строк
    k = max(len(start), len(end))
    
    # для большей скорости работать будем не со строками, а с битовыми масками
    # поэтому преобразуем двоичные строки вида ""0010..."" в целые числа
    start, end = int(start,2), int(end,2)
    
    # начальная и конечная точка пути должны различаться,
    # иначе алгоритм отработает некорретно
    assert start != end, '%s and %s must be different' % (start, end)

    # в множестве visited будем запоминать уже использованные в путях вершины
    visited = set()
    
    # в массиве result мы будем накапливать полученные пути
    # в принципе, можно было бы их просто печатать по мере получения,
    # но во время тестирования перебором различных входных строк
    # мне нужно было как-то запретить печать
    result = []

    # будем перебирать начальные вершины пути
    # сначала возьмём первую вершину без изменений,
    # потом изменим в ней крайний бит, потом следующий и т.д.
    # получится перебор k+1 начальных вершин, но одна из них будет
    # занята каким-то из путей в ходе поиска, и в итоге получится k путей
    for bit0 in [0] + [1<<i for i in range(k)]:
        # изменяем один из битов начальной вершины и генерируем вторую вершину пути
        # (первой всегда будет start)
        step = start ^ bit0

        # одна из потенциальных начальных вершин будет занята каким-то из путей в ходе поиска
        if step in visited:
            continue
        visited.add(step)

        # добавляем начальную вершину плюс вершину с изменённым битом (если изменяли) в путь
        path = [start] if step == start else [start, step]

        while 1:
            # целое число diff будет содержать единицы в тех битах,
            # которые отличаются между текущей и конечной вершинами
            diff = step ^ end
            if not diff:  # отличий не найдено,
                break     # путь достиг конечной точки

            # перебираем варианты следующего шага. ищем короткий путь: такой,
            # в котором число отличных от конечной вершины битов меньше на один
            while diff:
                bit = 1 << int(log(diff, 2))  # находим следующий ненулевой бит
                diff &= ~bit

                # следующий шаг должен либо привести в конечную (step == end),
                # либо в еще не занятую другими путями (step not in visited) вершину
                val = step ^ bit
                if val == end or val not in visited:
                    step = val         # запоминаем новую вершину в текущей
                    visited.add(step)  # добавляем в набор уже занятых вершин
                    path.append(step)  # и добавляем её в путь
                    break              # выходим из цикла перебора битов
            else:
                # если все вершины уже заняты, значит в алгоритме какая-то ошибка
                raise RuntimeError('no more paths for %s!' % input_str)

        # преобразуем путь из массива целых чисел в строковую форму и добавляем в результат
        result.append(' '.join(bin(val)[2:].rjust(k, '0') for val in path))

    # по теореме Менгера мы должны получить ровно k путей, проверим корректность результата
    assert len(result) == k, '%d paths for %s!' % (len(result), input_str)
    return result

# распечатаем результат, по одному пути в каждой строке
print(*kpaths(input()), sep='\n') 